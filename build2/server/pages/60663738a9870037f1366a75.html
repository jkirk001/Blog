<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Evron.dev :: Blog</title><link rel="icon" href="/favicon.ico"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&amp;display=swap" rel="stylesheet"/><meta name="next-head-count" content="6"/><link rel="preload" href="/_next/static/css/faed046866edf0d670cc.css" as="style"/><link rel="stylesheet" href="/_next/static/css/faed046866edf0d670cc.css" data-n-g=""/><link rel="preload" href="/_next/static/css/fe6c5fc6b1b2e8ff1608.css" as="style"/><link rel="stylesheet" href="/_next/static/css/fe6c5fc6b1b2e8ff1608.css" data-n-p=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-406be0e569a30b4da00d.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-ec03ce3c2268b708efc8.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.1cddd991bfe63666dc71.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.3ec46da15c53476879ea.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-69d3adaddd58352e7fa0.js" as="script"/><link rel="preload" href="/_next/static/chunks/cf37015caa9135a90a01f17846dc0327605555fb.7440adcf0690f9ba7d6d.js" as="script"/><link rel="preload" href="/_next/static/chunks/28708e6970a85c7ce074065856d94cef4f0b7335.bd4bff8329d7beee378e.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/%5Bpid%5D-90529993a39b97c1ca5f.js" as="script"/></head><body><div id="__next"><div class="Layout_containerLight__mem-Q"><header class="Layout_navbar__1QSDD"><img src="/logo2.png"/><div class="Layout_navLinks__3oMn4"><a href="/">Home</a><a href="/allPosts">All Posts</a><a href="/chron">Chronological</a><a href="/topics">Topics</a><a href="/post">Post</a></div></header><main class="Layout_main__197p6"><div class="singlePage_singlePost__3cHVc"><h1 class="HeaderDisplay_title__2_Tbv">Insertion sort and Evron.dev — Theory</h1><div class="icons_iconContainer__3REui"><img class="icons_img__DeXwq" src="/devLogos/JS.svg"/></div><div class="Author_authorInfo__cOpDX"><span>Author:<strong> Jon Evron</strong></span><span>Date: <strong>3/22/2021</strong></span><span>5 Minute Read</span></div><div class="HeaderDisplay_info__1_l50"><img src="https://res.cloudinary.com/dxtqihvgt/image/upload/v1617148584/Blog%20Images/sort_ticpka.jpg"/></div><div class="PostData_postMain__1R-Rt"><span class="PostData_postQuote__WBVXU">&quot;<!-- -->It may be easy, but the other ones are hard<!-- -->&quot;</span><h2>What is insertion sort?</h2><p>Insertion sort if one of the simpler commonly used sorting algorithms. In our case, as web developers, it is a sorting algorithm often used for its simplicity and speed when working with small or partially ordered datasets. So a blog page with 100 or so posts that are stored in a quasi ordered manner ( maybe its stored in month based clusters or your DB partially orders by ID — this is a big if, as data may seem ordered initially but it WILL NOT remain consistent in most DBs ).</p><h2>What is insertion sort not great for?</h2><p>Insertion sort is not great for large random datasets. If you have a large RESTful collection of data, that may be added to, removed from or modified at any time, insertion sort is one of the slowest sorting algorithms you can choose. This blog post is not what you should reference. But the info is likely still valuable.</p><h2>How does insertion sort work?</h2><p>Insertion sort works by finding a pivot point, in the case of insertion sort usually the first or last element in the array, then comparing each item to it and moving that item to the correct side of it.
</p><p>As we move down ( or up) the array, a trail of ordered elements is left in the wake. </p><p>It doesn’t sound as intuitive as it looks. Thanks to Hacker I have a few visualizations below. If you would like to play with this tool yourself check out &lt;a href=“https://www.hackerearth.com/practice/algorithms/sorting/insertion-sort/visualize/&quot; /&gt;</p><img src="https://res.cloudinary.com/dxtqihvgt/image/upload/v1617148719/Blog%20Images/InsertionSort/Insertion_Sort_v_saup5l.png"/><p>In this instance, we’ll select the initial element array[0] as our pivot point.</p><p>And the first step is to compare [0] to [1]. [1] is smaller than [0] so now [0] = 191 and [1] = 914.
</p><img src="https://res.cloudinary.com/dxtqihvgt/image/upload/v1617148719/Blog%20Images/InsertionSort/Insertion_Sort_v_1_msi4bo.png"/><p>Then again with [1] and [2]. But this time [2] is greater than [1] so they stay in place. </p><p>So now we look at [3].</p><p>Since [3] was smaller than [2] we swap them. Then we look at [2] and [1], and since [2] is smaller than [1] we swap again, leaving us with this</p><img src="https://res.cloudinary.com/dxtqihvgt/image/upload/v1617148718/Blog%20Images/InsertionSort/Insertion_Sort_v_2_z9pyc9.png"/><p>Now from here, this is the last example ill show, we compare [4] to [3] — swap. Then [3] to [2] — swap. Then [2] to [1] — STOP. Leaving us with</p><img src="https://res.cloudinary.com/dxtqihvgt/image/upload/v1617148718/Blog%20Images/InsertionSort/Insertion_Sort_v_3_gjweju.png"/><p>The pattern continues all the way down until we are left with an ordered list.
</p><img src="https://res.cloudinary.com/dxtqihvgt/image/upload/v1617148718/Blog%20Images/InsertionSort/Insertion_Sort_v_4_omvse4.png"/><h2>Thoughts on insertion sort</h2><p>As you can see from the bar graph visualization, if your dataset is large and unsorted it can be grueling process. But with small sets and partially ordered large sets, insertion is amazing quick for how simple it actually is.</p><p>And while you can get better performance from recursive and more conceptually challenging sorting methods, there really is no need for most projects. </p><p>Why lot when little do?</p><p>This post will be updated with a link to the practical code sibling post</p></div></div></main><footer class="Layout_footer__13IKe"><span>2021 ©</span><span>Something Else</span></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"author":{"date":"Thu Apr 01 2021 14:12:19 GMT-0700 (Pacific Daylight Time)","name":"Jon","read":5},"tags":["JS"],"body":[{"type":"sub","content":"What is insertion sort?"},{"type":"p","content":"Insertion sort if one of the simpler commonly used sorting algorithms. In our case, as web developers, it is a sorting algorithm often used for its simplicity and speed when working with small or partially ordered datasets. So a blog page with 100 or so posts that are stored in a quasi ordered manner ( maybe its stored in month based clusters or your DB partially orders by ID — this is a big if, as data may seem ordered initially but it WILL NOT remain consistent in most DBs )."},{"type":"sub","content":"What is insertion sort not great for?"},{"type":"p","content":"Insertion sort is not great for large random datasets. If you have a large RESTful collection of data, that may be added to, removed from or modified at any time, insertion sort is one of the slowest sorting algorithms you can choose. This blog post is not what you should reference. But the info is likely still valuable."},{"type":"sub","content":"How does insertion sort work?"},{"type":"p","content":"Insertion sort works by finding a pivot point, in the case of insertion sort usually the first or last element in the array, then comparing each item to it and moving that item to the correct side of it.\n"},{"type":"p","content":"As we move down ( or up) the array, a trail of ordered elements is left in the wake. "},{"type":"p","content":"It doesn’t sound as intuitive as it looks. Thanks to Hacker I have a few visualizations below. If you would like to play with this tool yourself check out \u003ca href=“https://www.hackerearth.com/practice/algorithms/sorting/insertion-sort/visualize/\" /\u003e"},{"type":"img","content":"https://res.cloudinary.com/dxtqihvgt/image/upload/v1617148719/Blog%20Images/InsertionSort/Insertion_Sort_v_saup5l.png"},{"type":"p","content":"In this instance, we’ll select the initial element array[0] as our pivot point."},{"type":"p","content":"And the first step is to compare [0] to [1]. [1] is smaller than [0] so now [0] = 191 and [1] = 914.\n"},{"type":"img","content":"https://res.cloudinary.com/dxtqihvgt/image/upload/v1617148719/Blog%20Images/InsertionSort/Insertion_Sort_v_1_msi4bo.png"},{"type":"p","content":"Then again with [1] and [2]. But this time [2] is greater than [1] so they stay in place. "},{"type":"p","content":"So now we look at [3]."},{"type":"p","content":"Since [3] was smaller than [2] we swap them. Then we look at [2] and [1], and since [2] is smaller than [1] we swap again, leaving us with this"},{"type":"img","content":"https://res.cloudinary.com/dxtqihvgt/image/upload/v1617148718/Blog%20Images/InsertionSort/Insertion_Sort_v_2_z9pyc9.png"},{"type":"p","content":"Now from here, this is the last example ill show, we compare [4] to [3] — swap. Then [3] to [2] — swap. Then [2] to [1] — STOP. Leaving us with"},{"type":"img","content":"https://res.cloudinary.com/dxtqihvgt/image/upload/v1617148718/Blog%20Images/InsertionSort/Insertion_Sort_v_3_gjweju.png"},{"type":"p","content":"The pattern continues all the way down until we are left with an ordered list.\n"},{"type":"img","content":"https://res.cloudinary.com/dxtqihvgt/image/upload/v1617148718/Blog%20Images/InsertionSort/Insertion_Sort_v_4_omvse4.png"},{"type":"sub","content":"Thoughts on insertion sort"},{"type":"p","content":"As you can see from the bar graph visualization, if your dataset is large and unsorted it can be grueling process. But with small sets and partially ordered large sets, insertion is amazing quick for how simple it actually is."},{"type":"p","content":"And while you can get better performance from recursive and more conceptually challenging sorting methods, there really is no need for most projects. "},{"type":"p","content":"Why lot when little do?"},{"type":"p","content":"This post will be updated with a link to the practical code sibling post"}],"_id":"60663738a9870037f1366a75","title":"Insertion sort and Evron.dev — Theory","quip":"It may be easy, but the other ones are hard","mainImg":"https://res.cloudinary.com/dxtqihvgt/image/upload/v1617148584/Blog%20Images/sort_ticpka.jpg","__v":0}},"__N_SSG":true},"page":"/[pid]","query":{"pid":"60663738a9870037f1366a75"},"buildId":"kSnwhyNUfqR1rxGdI3iBG","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-70afb64d1115f93cf0f7.js"></script><script src="/_next/static/chunks/main-406be0e569a30b4da00d.js" async=""></script><script src="/_next/static/chunks/webpack-ec03ce3c2268b708efc8.js" async=""></script><script src="/_next/static/chunks/framework.1cddd991bfe63666dc71.js" async=""></script><script src="/_next/static/chunks/commons.3ec46da15c53476879ea.js" async=""></script><script src="/_next/static/chunks/pages/_app-69d3adaddd58352e7fa0.js" async=""></script><script src="/_next/static/chunks/cf37015caa9135a90a01f17846dc0327605555fb.7440adcf0690f9ba7d6d.js" async=""></script><script src="/_next/static/chunks/28708e6970a85c7ce074065856d94cef4f0b7335.bd4bff8329d7beee378e.js" async=""></script><script src="/_next/static/chunks/pages/%5Bpid%5D-90529993a39b97c1ca5f.js" async=""></script><script src="/_next/static/kSnwhyNUfqR1rxGdI3iBG/_buildManifest.js" async=""></script><script src="/_next/static/kSnwhyNUfqR1rxGdI3iBG/_ssgManifest.js" async=""></script></body></html>